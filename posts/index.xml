<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Nathan Chancellor</title>
        <link>https://nathanchance.dev/posts/</link>
        <description>Recent content in Posts on Nathan Chancellor</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Wed, 15 Apr 2020 15:11:58 -0700</lastBuildDate>
        <atom:link href="https://nathanchance.dev/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Art of git revert</title>
            <link>https://nathanchance.dev/posts/art-of-git-revert/</link>
            <pubDate>Wed, 15 Apr 2020 15:11:58 -0700</pubDate>
            
            <guid>https://nathanchance.dev/posts/art-of-git-revert/</guid>
            <description>I have always loved reading good commit messages and I have tried myself to write good commit messages to inspire others to do the same. I see good commit messages as important for two reasons: it allows people who work on a project afterwards to understand the context behind a change (so that you don&amp;rsquo;t have a denvercoder9 situation) and it allows other people to get familiar with your project by fully understanding the why behind a change.</description>
            <content type="html"><![CDATA[<p>I have always loved reading <a href="https://chris.beams.io/posts/git-commit/">good commit messages</a> and I have tried myself to write good commit messages to inspire others to do the same. I see good commit messages as important for two reasons: it allows people who work on a project afterwards to understand the context behind a change (so that you don&rsquo;t have a <a href="https://xkcd.com/979/">denvercoder9 situation</a>) and it allows other people to get familiar with your project by fully understanding the why behind a change. I learned a lot about the Linux kernel purely through reading the commit messages in certain subsystems.</p>
<p>I see some projects (like amateur Android ROMs and kernels) write really good commmit messages for &ldquo;normal&rdquo; commits but leave the default &ldquo;This reverts commit&hellip;&rdquo; message for reverts, with no additional comments. One of the first points I want to make with this post are <strong>revert commits are still commits</strong>. Just because <code>git</code> fills in the commit message does not mean that it should not be supplemented.</p>
<p>Some things worth considering when writing a commit message for a revert:</p>
<ul>
<li>
<p><strong>Why is the revert actually being done?</strong> Is it just not necessary? Did it break something? Leaving out the why of the revert defeats the purpose. Presumably, if the commit was applied in the first place, it had good reason for being there. If it did not, that should be in the commit message of the revert.</p>
</li>
<li>
<p><strong>If it is broken, how would one notice?</strong> Forks of a common upstream like AOSP or the Linux kernel will often have overlapping commits. If someone finds an issue with one, the visible effects of that issue should be noted so that others have a chance to do their own investigation. For example, if a commit introduces a crash, the output of the stacktrace would be relevant for the commit message so that other people have the opportunity to analyze it.</p>
</li>
<li>
<p><strong>How can issues be avoided in the future?</strong> Any time that a revert happens, it is a learning opportunity. Where did the breakdown happen in the original commit&rsquo;s process? Was it not reviewed properly (or at all)? Was it tested? If so, how? Are there tests that can expose an issue in the future? If not, is it worth writing one?</p>
</li>
</ul>
<p>Some people are very liberal with reverts or removing commits through rebasing and force pushing. Reverts are an opportunity to look at your software development process and improve it so that they do not happen as much in the future. I did this a lot with my custom Android kernels. Initially, I would rebase and force push my repos when I found issues. Over time, I learned that it is best to fully review and test a commit or series of commits before pushing into a release so that reverting/rebasing was not necessary. It made for a much more stable and painless experience for me and as well as my users.</p>
<p>In future posts, I will explore some ways to justify a change initially so that reverting it does not happen so stay tuned. If you have any questions or comments, feel free to reach out to me on <a href="https://twitter.com/nathanchance">Twitter</a>.</p>
]]></content>
        </item>
        
        <item>
            <title>Creating WSL 2 distributions from LXC images</title>
            <link>https://nathanchance.dev/posts/wsl2-distros-from-lxc-images/</link>
            <pubDate>Wed, 15 Apr 2020 12:40:20 -0700</pubDate>
            
            <guid>https://nathanchance.dev/posts/wsl2-distros-from-lxc-images/</guid>
            <description>I have been a big fan of Windows Subsystem for Linux 2 as I need Windows for school but I am so used to the command line for remoting into my server and automating various tasks locally. For those of you who do not know, WSL 2 uses a Linux kernel under the hood (which I customize here) and all of the various distributions that you can run are basically containers on top of it.</description>
            <content type="html"><![CDATA[<p>I have been a big fan of Windows Subsystem for Linux 2 as I need Windows for school but I am so used to the command line for remoting into my server and automating various tasks locally. For those of you who do not know, WSL 2 uses a Linux kernel under the hood (which I customize <a href="https://github.com/nathanchance/WSL2-Linux-Kernel">here</a>) and all of <a href="https://docs.microsoft.com/en-us/windows/wsl/install-manual#downloading-distros">the various distributions</a> that you can run are basically containers on top of it.</p>
<p>There is a little known option within <code>wsl.exe</code> named <code>--import</code> that allows you to create a WSL distribution from any Linux distribution&rsquo;s rootfs. I use the images available on the <a href="https://jenkins.linuxcontainers.org/">LXC Jenkins instance</a>. Here is a basic how-to (assuming you already have <a href="https://docs.microsoft.com/en-us/windows/wsl/wsl2-install">WSL 2 installed</a>):</p>
<h3 id="1-download-and-extract-lxc-image">1. Download and extract LXC image</h3>
<p>Go to the <a href="https://jenkins.linuxcontainers.org/view/Images/">LXC images page</a> and select a distribution that you want. I will use Alpine Linux because it is really small and nice for doing quick tasks/tests.</p>
<p>Click on the image link then find the &ldquo;amd64&rdquo; version of the image (assuming you have an Intel or AMD processor) with the particular version that you want (it will probably have a green dot). I am using <a href="https://jenkins.linuxcontainers.org/view/Images/job/image-alpine/architecture=amd64,release=edge,variant=default/">Alpine&rsquo;s edge version</a>. You should see a link for a <code>rootfs.tar.xz</code>; click on it to download it.</p>
<p>Once it is downloaded, extract it using something like <a href="https://www.7-zip.org/">7-Zip</a> (I use the &ldquo;Extract Here&rdquo; option). Once you have the raw <code>rootfs.tar</code> file, we are good to go.</p>
<h3 id="2-import-the-rootfs">2. Import the rootfs</h3>
<p>Open up a PowerShell instance (I use Windows Terminal). The format of <code>wsl.exe --import</code> is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">&gt; wsl.exe --import &lt;distro_name&gt; &lt;distro_folder&gt; &lt;rootfs&gt;
</code></pre></div><p>I have a <code>Linux</code> folder in my user account where I house all of my Linux files so that is where I am going to install it. By default, PowerShell spawns me in my user folder so I am going to use relative paths.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">&gt; wsl.exe --import alpine .\Linux\alpine .\Downloads\rootfs.tar
</code></pre></div><h3 id="3-run-the-distro-and-start-setting-it-up">3. Run the distro and start setting it up</h3>
<p>Once you have imported the rootfs, the distribution is now available to spawn into with <code>wsl.exe</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">&gt; wsl.exe -d alpine
<span style="color:#75715e"># uname</span>
Linux
</code></pre></div><p>I recommend getting the distribution up to date right out of the gate (Google instructions for the specific distribution you chose):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># apk update</span>
fetch http://dl-cdn.alpinelinux.org/alpine/edge/main/x86_64/APKINDEX.tar.gz
fetch http://dl-cdn.alpinelinux.org/alpine/edge/community/x86_64/APKINDEX.tar.gz
v20200319-2352-g9a801feaea <span style="color:#f92672">[</span>http://dl-cdn.alpinelinux.org/alpine/edge/main<span style="color:#f92672">]</span>
v20200319-2346-g9aab507aee <span style="color:#f92672">[</span>http://dl-cdn.alpinelinux.org/alpine/edge/community<span style="color:#f92672">]</span>
OK: <span style="color:#ae81ff">12421</span> distinct packages available
<span style="color:#75715e"># apk upgrade</span>
OK: <span style="color:#ae81ff">39</span> MiB in <span style="color:#ae81ff">25</span> packages
</code></pre></div><p>After this, I recommend setting up a user account like an official WSL distribution would:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># adduser nathan</span>
Changing password <span style="color:#66d9ef">for</span> nathan
New password:
Retype password:
passwd: password <span style="color:#66d9ef">for</span> nathan changed by root
</code></pre></div><p>After this, you should give yourself the ability to use <code>sudo</code> to avoid logging into the <code>root</code> account constantly. It is recommended that you use <code>visudo</code> and insert yourself after the <code>root    ALL=(ALL) ALL</code> line. There are plenty of resources on Google for how to give yourself <code>sudo</code> access, follow those instead of me :)</p>
<p>Once you have created your user account, you can tell WSL to use it by default when you run <code>wsl.exe -d &lt;name&gt;</code> through <code>/etc/wsl.conf</code> (obviously replace my name with the one you chose with <code>adduser</code> above):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># cat &lt;&lt;EOF &gt; /etc/wsl.conf</span>
<span style="color:#f92672">[</span>user<span style="color:#f92672">]</span>
default <span style="color:#f92672">=</span> nathan
EOF
</code></pre></div><p>To have these changes get reflected in the distro, restart it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">&gt; wsl.exe -d alpine
<span style="color:#75715e"># whoami</span>
root
<span style="color:#75715e"># exit</span>
&gt; wsl.exe --terminate alpine
&gt; wsl.exe -d alpine
$ whoami
nathan
</code></pre></div><p>Hopefully this was somewhat informative. This process might work with Docker images as well since they are usually created from a raw rootfs as well (see <a href="https://github.com/debuerreotype/docker-debian-artifacts/tree/c7d149fa1214588199f3f0b8c30851b9cea47c6b/stable">Debian&rsquo;s</a> for example), feel free to give it a try. I have been uncovering more and more things with WSL 2 lately that I hope to continue to share here. If you have any questions or comments, feel free to reach out to me on <a href="https://twitter.com/nathanchance">Twitter</a>.</p>
]]></content>
        </item>
        
        <item>
            <title>Building and using Cuttlefish</title>
            <link>https://nathanchance.dev/posts/building-using-cuttlefish/</link>
            <pubDate>Fri, 31 Jan 2020 18:52:00 -0700</pubDate>
            
            <guid>https://nathanchance.dev/posts/building-using-cuttlefish/</guid>
            <description>Recently, I stumbled upon a talk that Alistair Delva, a Google engineer, gave at the 2018 Linux Plumbers Conference around Cuttlefish, an Android Virtual Device (AVD) that is used to validate the Android platform virtually (i.e. without a separate device). This is something that is really cool because it makes it easy to follow along with upstream Android development and see what changes they are making under the hood, all from adb shell.</description>
            <content type="html"><![CDATA[<p>Recently, I stumbled upon <a href="https://youtu.be/xMtDDEj-02c?t=9502">a talk</a> that Alistair Delva, a Google engineer, gave at the 2018 Linux Plumbers Conference around Cuttlefish, an Android Virtual Device (AVD) that is used to validate the Android platform virtually (i.e. without a separate device). This is something that is really cool because it makes it easy to follow along with upstream Android development and see what changes they are making under the hood, all from <code>adb shell</code>. Cuttlefish boots in around 20 seconds on my machine and swapping out kernels is as simple as adding two command flags which I will go over later. If you are running Cuttlefish locally, you can even <a href="https://android.googlesource.com/device/google/cuttlefish/#so-you-want-to-see-cuttlefish">view it</a> with TightVNC.</p>
<p>A brief demo:</p>
<p><a href="https://asciinema.org/a/tfDhVZKCL0URqP58lnxuRsKZd"><img src="https://asciinema.org/a/tfDhVZKCL0URqP58lnxuRsKZd.svg" alt="asciicast"></a></p>
<p>A few things to note:</p>
<ol>
<li>
<p>These commands assume that you understand Linux shell commands and structure; do not blindly copy and paste (even though everything should work without any issues). If you have any questions about what something is specifically doing and I did not make it clear enough here, feel free to reach out to me on Twitter (link on my homepage).</p>
</li>
<li>
<p>All of the commands are specifically for Ubuntu. This is the OS that I use with my <a href="https://www.packet.com/">Packet</a> servers and all that I really test on. I tested both <code>bash</code> and <code>zsh</code> without any issues. Debian <em>should</em> work but since we are dealing with fairly low level stuff like KVM, there might be minor differences that are not accounted for here.</p>
</li>
</ol>
<h2 id="1-getting-cuttlefish-running">1. Getting Cuttlefish running</h2>
<p>The first thing to do is actually get the images and tools we need downloaded and installed. This has mostly been distilled from <a href="https://android.googlesource.com/device/google/cuttlefish/#so-you-want-to-try-cuttlefish">the official README</a>. Cuttlefish uses KVM for performance so your device must support virtualization. See <a href="http://www.linux-kvm.org/page/Processor_support">this page</a> for how to determine that and consult Google for how to enable it in your BIOS if it is not already.</p>
<p>To start, we need to grab a bunch of packages that are essential to this process:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install -y build-essential devscripts fakeroot git psmisc qemu-kvm unzip zip
</code></pre></div><p>Next, we will make a folder to contain all of the work we are doing. This can be anywhere but you will need to adjust the rest of the commands for wherever you put it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir -p <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/src
</code></pre></div><p>After this, we will clone the android-cuttlefish repo locally. This will configure and install some tools that are necessary to boot Cuttlefish. Most of these tools are for development, the main reason to install this package is to get the groups that Cuttlefish needs configured properly. There is also the option of using a Docker image to do this but when I tried to use it, I could not get it to work.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git clone https://github.com/google/android-cuttlefish <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/src/android-cuttlefish
$ cd <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/src/android-cuttlefish
</code></pre></div><p>Once the repo has been successfully cloned, we need to install a couple of prerequisite packages specifically for this package we are about to build.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install -y cdbs config-package-dev debhelper
</code></pre></div><p>After those have been installed, we will build the package:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ debuild -i -us -uc -b
</code></pre></div><p>The package should have built successfully. If it did not, see if it says a package is missing or try Googling the error to get it resolved. Once it is built, try to install it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo dpkg -i ../cuttlefish-common_*_amd64.deb
</code></pre></div><p>That step will fail. The packages that it depends on can be installed along with it by running the following command:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install -f -y
</code></pre></div><p>Once it gets installed successfully, the <code>cuttlefish-*</code> packages can be removed to avoid cluttering up the workspace.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ rm ../cuttlefish-*
</code></pre></div><p>After this, we need to add our user to the <code>cvdnetwork</code> and <code>kvm</code> network so that Cuttlefish is allowed to use KVM to boot and configure its network using vsock.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo usermod -aG cvdnetwork <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>USER<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
$ sudo usermod -aG kvm <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>USER<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</code></pre></div><p>Once that is done, logout and log back in (or reboot your machine if it is a remote server).</p>
<p>After logging back in, we need to grab prebuilt versions of the Cuttlefish host tools (such as the <code>launch_cvd</code> and <code>stop_cvd</code> commands) as well as the filesystem images, much like a regular Android device, which include <code>super.img</code>, <code>vendor.img</code>, and <code>boot.img</code>. I will show you how to build these from source if you ever want to hack on Cuttlefish later.</p>
<p>We will first create an area for all of this to exist.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir -p <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/cuttlefish-fs
$ cd <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/cuttlefish-fs
</code></pre></div><p>The files we need are all available from <a href="https://ci.android.com">ci.android.com</a>. There will be a LOT of different options, the one we care about is currently the second column: <code>aosp_cf_x86_phone</code>. If you click on the <strong>userdebug</strong> button, it will automatically give you the last known good build. From there, click on the button with the arrow then click on <strong>Artifacts</strong>. The files we need to download are <code>aosp_cf_x86_phone-img-*.zip</code> and <code>cvd-host_package.tar.gz</code>.</p>
<p>This one-liner will grab the zip, unzip it, and remove it. I recommend using the latest, known good build, instead of the one that I have linked here.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -LSsO https://ci.android.com/builds/submitted/6173731/aosp_cf_x86_phone-userdebug/latest/aosp_cf_x86_phone-img-6173731.zip <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>unzip *.zip <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>rm *.zip
</code></pre></div><p>This one-liner will grab the host tools and untar it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -LSs https://ci.android.com/builds/submitted/6173731/aosp_cf_x86_phone-userdebug/latest/cvd-host_package.tar.gz | tar -xzf -
</code></pre></div><p>Once those have finished downloading, we are ready to run Cuttlefish! We start Cuttlefish using the <code>launch_cvd</code> (Launch Cuttlefish Virtual Device).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ HOME<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>PWD<span style="color:#e6db74">}</span> ./bin/launch_cvd -daemon
</code></pre></div><p>The <code>HOME=${PWD}</code> is present so that some Cuttlefish runtime files get contained to this folder. The <code>-daemon</code> flag is so that we can interact with Cuttlefish through <code>adb shell</code> in the same terminal window (i.e. it gets sent to the background). You should see a bunch of text fire up then it end with something like:</p>
<pre><code>run_cvd I 01-31 20:07:50  9571  9571 main.cc:198] VIRTUAL_DEVICE_BOOT_COMPLETED
launch_cvd I 01-31 20:07:50  9543  9543 launch_cvd.cc:131] run_cvd exited successfully.
</code></pre><p>It takes about 20 seconds for Cuttlefish to boot up for me (which is extremely impressive in my opinion). After that, you can run <code>adb</code> to connect to it. You might need to run the command a couple of times so that <code>adb</code> can start and connect to the device but once you do, you should be able to interact with it like any other Android device.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./bin/adb shell
vsoc_x86:/ $
</code></pre></div><p>I like to see what kernel it is running, which at this point is the <code>android-5.4</code> branch, the latest LTS kernel.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">vsoc_x86:/ $ cat /proc/version
Linux version 5.4.15-gb2b96d09ef40 <span style="color:#f92672">(</span>android-build@abfarm-01061<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>Android <span style="color:#f92672">(</span><span style="color:#ae81ff">6051079</span> based on r370808<span style="color:#f92672">)</span> clang version 10.0.1 <span style="color:#f92672">(</span>https://android.googlesource.com/toolchain/llvm-project b9738d6d99f614c8bf7a3e7c769659b313b88244<span style="color:#f92672">))</span> <span style="color:#75715e">#1 SMP PREEMPT Mon Jan 27 13:04:43 UTC 2020</span>
</code></pre></div><p>You can see that it actively running tasks by typing in <code>top</code>. Once you are done exploring and want to move on, shutdown this instance by calling <code>stop_cvd</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ HOME<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>PWD<span style="color:#e6db74">}</span> ./bin/stop_cvd
</code></pre></div><h2 id="2-building-your-own-kernel">2. Building your own kernel</h2>
<p>Now that we have gotten Cuttlefish running, it&rsquo;s time to explore one of the main reasons that I use it, which is validating Android kernels. Android has cool technologies in the kernel such as LTO and CFI, which are not currently in mainline. Replacing Cuttlefish&rsquo;s prebuilt kernel is extremely easy, which is one of the main selling points; it makes it really easy for kernel hackers to get involved with it, especially with Google&rsquo;s kernel build system. This section is expanded from <a href="https://source.android.com/setup/build/building-kernels">Google&rsquo;s official documentation</a>.</p>
<p>First, we need to do is grab <code>repo</code>, Google&rsquo;s <code>git</code> management tool. If you already have <code>repo</code> installed, just skip this portion. Alternatively, you can install <code>repo</code> into <code>/usr/local/bin</code> so that it is automatically added to <code>PATH</code> but for the sake of this tutorial, I keep everything localized as much as possible.</p>
<p>Create a <code>bin</code> folder within the Cuttlefish area.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir -p <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/bin
</code></pre></div><p>Download <code>repo</code> into the <code>bin</code> folder.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -LSso <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/bin/repo https://storage.googleapis.com/git-repo-downloads/repo
</code></pre></div><p>Make it executable.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod a+x <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/bin/repo
</code></pre></div><p>Add the <code>bin</code> folder to <code>PATH</code> (NOTE: If you close out of your terminal session or start a new one, you will need to do this everytime):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ export PATH<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span>/cuttlefish-playground/bin:<span style="color:#e6db74">${</span>PATH<span style="color:#e6db74">}</span>
</code></pre></div><p>If you have not already configured <code>git</code> with your email address and your full name, do so now:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git config --global user.email <span style="color:#e6db74">&#34;you@domain.com&#34;</span>
$ git config --global user.name <span style="color:#e6db74">&#34;Your Name
</span></code></pre></div><p>After all of this has been configured, we are going to download the kernel source. Depending on your internet speed, this might take some time.</p>
<p>We will create a folder for that source to be saved in. This will also download all of the prebuilt tools we need, such as the compiler and binaries used during the build process.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir -p <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/kernel-common
$ cd <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/kernel-common
</code></pre></div><p>Next, we will download the source. I am using the <code>common-android-mainline</code> branch since it is the latest available and where most of the new development happens but you can use <code>common-android-5.4</code> or <code>common-android-4.19</code> branches if you would like. Any time that you want to get the latest new changes, you can just run <code>repo sync</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ repo init -u https://android.googlesource.com/kernel/manifest -b common-android-mainline
$ repo sync
</code></pre></div><p>Once it is done downloading, we need to make sure that we have the SSL development headers installed, otherwise our build will error out. Google&rsquo;s build is almost heremetic, except for this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install -y libssl-dev
</code></pre></div><p>Finally, we are ready to build the kernel. Google&rsquo;s build script takes care of everything as long as we specify a build config, which is <code>build.config.cuttlefish.x86_64</code> in our case. We need to copy the <code>bzImage</code> into the <code>dist</code> folder because Google&rsquo;s <code>build.config.cuttlefish.x86_64</code> is only intended to save the <code>initramfs.img</code>; however, the <code>build.config.gki.x86_64</code> is about to be fully demodularized and we are eventually going to use a different compiler than Google&rsquo;s official one, which will create a mismatch. As a result, we need to do that copy on our own (it isn&rsquo;t strictly necessary, it just makes everything end up in the right spot).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ BUILD_CONFIG<span style="color:#f92672">=</span>common/build.config.cuttlefish.x86_64 ./build/build.sh
$ cp out/android-mainline/common/arch/x86/boot/bzImage out/android-mainline/dist/bzImage
</code></pre></div><p>Once it is done building, we can use that kernel and ramdisk to boot from. <code>launch_cvd</code> has two flags we need to use, <code>-initramfs_path</code> (for the ramdisk that has all of the kernel modules) and <code>-kernel_path</code> for the actual kernel binary. These two files are available in the <code>out/&lt;branch&gt;/dist</code> folder (e.g., <code>out/android-mainline/dist</code>). I would recommend exporting this to a variable that can be easily used later.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ DIST_FOLDER<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>readlink -f out/android-mainline/dist<span style="color:#66d9ef">)</span>
</code></pre></div><p>Once you do that, we will move back to the <code>cuttlefish-fs</code> folder and use these freshly built files to boot Cuttlefish from:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cd <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/cuttlefish-fs
$ HOME<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>PWD<span style="color:#e6db74">}</span> ./bin/launch_cvd -daemon -initramfs_path <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>DIST_FOLDER<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/initramfs.img -kernel_path <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>DIST_FOLDER<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/bzImage
</code></pre></div><p>After that, we can use <code>adb shell</code> to see that we indeed used our own kernel since it shows a newer version, different user/hostname, and the repo that we used and that all of the modules properly loaded.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./bin/adb shell
vsoc_x86:/ $ cat /proc/version
Linux version 5.5.0-mainline-03266-g1dad8acc36fc <span style="color:#f92672">(</span>nathan@g2-large-x86<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>Android <span style="color:#f92672">(</span><span style="color:#ae81ff">6051079</span> based on r370808<span style="color:#f92672">)</span> clang version 10.0.1 <span style="color:#f92672">(</span>https://android.googlesource.com/toolchain/llvm-project b9738d6d99f614c8bf7a3e7c769659b313b88244<span style="color:#f92672">))</span> <span style="color:#75715e">#1 repo:common-android-mainline SMP PREEMPT Fri Jan 31 21:42:55</span>
vsoc_x86:/ $ lsmod
Module                  Size  Used by
vsock_loopback         <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">0</span>
vmw_vsock_virtio_transport    <span style="color:#ae81ff">24576</span>  <span style="color:#ae81ff">3</span>
vmw_vsock_virtio_transport_common    <span style="color:#ae81ff">36864</span>  <span style="color:#ae81ff">2</span> vsock_loopback,vmw_vsock_virtio_transport
vsock_diag             <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">0</span>
vsock                  <span style="color:#ae81ff">53248</span>  <span style="color:#ae81ff">16</span> vsock_loopback,vmw_vsock_virtio_transport,vmw_vsock_virtio_transport_common,vsock_diag
can_raw                <span style="color:#ae81ff">20480</span>  <span style="color:#ae81ff">0</span>
can                    <span style="color:#ae81ff">28672</span>  <span style="color:#ae81ff">1</span> can_raw
snd_intel8x0           <span style="color:#ae81ff">45056</span>  <span style="color:#ae81ff">1</span>
snd_ac97_codec        <span style="color:#ae81ff">229376</span>  <span style="color:#ae81ff">1</span> snd_intel8x0
ac97_bus               <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">1</span> snd_ac97_codec
virtio_input           <span style="color:#ae81ff">20480</span>  <span style="color:#ae81ff">0</span>
virtio_pci             <span style="color:#ae81ff">28672</span>  <span style="color:#ae81ff">0</span>
virtio_mmio            <span style="color:#ae81ff">20480</span>  <span style="color:#ae81ff">0</span>
gnss_cmdline           <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">0</span>
gnss_serial            <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">1</span> gnss_cmdline
virtio_crypto          <span style="color:#ae81ff">28672</span>  <span style="color:#ae81ff">0</span>
dummy_cpufreq          <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">0</span>
rtc_test               <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">1</span>
dummy_hcd              <span style="color:#ae81ff">32768</span>  <span style="color:#ae81ff">0</span>
can_dev                <span style="color:#ae81ff">32768</span>  <span style="color:#ae81ff">0</span>
vcan                   <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">0</span>
virtio_net             <span style="color:#ae81ff">53248</span>  <span style="color:#ae81ff">0</span>
net_failover           <span style="color:#ae81ff">24576</span>  <span style="color:#ae81ff">1</span> virtio_net
failover               <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">1</span> net_failover
virt_wifi              <span style="color:#ae81ff">24576</span>  <span style="color:#ae81ff">1</span>
virtio_pmem            <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">1</span>
nd_virtio              <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">1</span> virtio_pmem
virtio_blk             <span style="color:#ae81ff">24576</span>  <span style="color:#ae81ff">5</span>
virtio_gpu             <span style="color:#ae81ff">57344</span>  <span style="color:#ae81ff">0</span>
virtio_console         <span style="color:#ae81ff">36864</span>  <span style="color:#ae81ff">0</span>
virtio_rng             <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">0</span>
virtio_ring            <span style="color:#ae81ff">36864</span>  <span style="color:#ae81ff">11</span> vmw_vsock_virtio_transport,virtio_input,virtio_pci,virtio_mmio,virtio_crypto,virtio_net,nd_virtio,virtio_blk,virtio_gpu,virtio_console,virtio_rng
virtio                 <span style="color:#ae81ff">24576</span>  <span style="color:#ae81ff">11</span> vmw_vsock_virtio_transport,virtio_input,virtio_pci,virtio_mmio,virtio_crypto,virtio_net,virtio_pmem,virtio_blk,virtio_gpu,virtio_console,virtio_rng
blk_mq_virtio          <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">1</span> virtio_blk
binfmt_misc            <span style="color:#ae81ff">20480</span>  <span style="color:#ae81ff">0</span>
</code></pre></div><p>Once you are done exploring, stop Cuttlefish.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ HOME<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>PWD<span style="color:#e6db74">}</span> ./bin/stop_cvd
</code></pre></div><h2 id="3-using-upstream-llvm">3. Using upstream LLVM</h2>
<p>One of my hobbies is contributing to <a href="https://github.com/ClangBuiltLinux">ClangBuiltLinux</a>, which involves building various Linux kernels with the master version of Clang (11.0.0 at the time of writing this). As a part of that project, I have developed a script that can build a self-contained version of Clang suitable for building kernels. These steps will show you how to build that version of Clang then use it within the Android build system.</p>
<p>First, we need to install some packages that allow us build Clang efficiently (including Clang itself):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install -y bc bison ccache clang cmake flex libelf-dev lld ninja-build python3 u-boot-tools zlib1g-dev
</code></pre></div><p>Next, we&rsquo;ll grab the repo that contains the Python script:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git clone git://github.com/ClangBuiltLinux/tc-build <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/src/tc-build
</code></pre></div><p>By default, the script does a two stage LLVM build (builds a small version of LLVM then uses that to build a full version of LLVM).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/src/tc-build/build-llvm.py
</code></pre></div><p>If for some reason your machine cannot handle that, you can just do a stage 1 build.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/src/tc-build/build-llvm.py --build-stage1-only --install-stage1-only
</code></pre></div><p>If you have a machine with good performance, I would recommend using the <code>--pgo</code> flag to build with Profile Guided Optimization; this can result in a 20% speed up when compiling kernels.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/src/tc-build/build-llvm.py --pgo
</code></pre></div><p>If for some reason there are any issues using the script, please report them <a href="https://github.com/ClangBuiltLinux/tc-build/issues">here</a> so I can triage them.</p>
<p>Once the toolchain has been built, we will make it available to easily use by symlinking the <code>install</code> folder within <code>tc-build</code> into the <code>prebuilts</code> folder in <code>kernel-common</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ln -s <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/src/tc-build/install <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/kernel-common/prebuilts-master/clang/host/linux-x86/cbl-clang-master
</code></pre></div><p>After that, we can use <code>sed</code> to automatically use that Clang when building the kernel.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cd <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/kernel-common
$ sed -i <span style="color:#e6db74">&#39;s/clang-r.*/cbl-clang-master\/bin/g&#39;</span> common/build.config.common
$ BUILD_CONFIG<span style="color:#f92672">=</span>common/build.config.cuttlefish.x86_64 ./build/build.sh
$ cp out/android-mainline/common/arch/x86/boot/bzImage out/android-mainline/dist/bzImage
</code></pre></div><p>Once the build is completed, we just use the same commands as before to boot and test:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ DIST_FOLDER<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>readlink -f out/android-mainline/dist<span style="color:#66d9ef">)</span>
$ cd <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/cuttlefish-fs
$ HOME<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>PWD<span style="color:#e6db74">}</span> ./bin/launch_cvd -daemon -initramfs_path <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>DIST_FOLDER<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/initramfs.img -kernel_path <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>DIST_FOLDER<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/bzImage
$ ./bin/adb shell
vsoc_x86:/ $ cat /proc/version
Linux version 5.5.0-mainline-03266-g1dad8acc36fc-dirty <span style="color:#f92672">(</span>nathan@g2-large-x86<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>ClangBuiltLinux clang version 11.0.0 <span style="color:#f92672">(</span>git://github.com/llvm/llvm-project 64cb77b9469207799e570483dadc720dbf12c794<span style="color:#f92672">))</span> <span style="color:#75715e">#1 repo:common-android-mainline SMP PREEMPT Fri Jan 31 23:47:57</span>
vsoc_x86:/ $ exit
$ HOME<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>PWD<span style="color:#e6db74">}</span> ./bin/stop_cvd
</code></pre></div><h2 id="4-building-cuttlefish-userspace-from-scratch">4. Building Cuttlefish userspace from scratch</h2>
<p>If you want to test the latest and greatest from AOSP&rsquo;s master branch, you can build the things that are in the <code>cuttlefish-fs</code> folder from scratch.</p>
<p>This is not small so make sure that you have room on your hard drive for it. A fresh checkout as of today shows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ diskus .
92.68 GB <span style="color:#f92672">(</span>92,677,562,368 bytes<span style="color:#f92672">)</span>
</code></pre></div><p>First, use <code>repo</code> to go and grab the full AOSP source tree.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir -p <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/src/aosp
$ cd <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/cuttlefish-playground/src/aosp
$ repo init -u https://android.googlesource.com/platform/manifest
$ repo sync
</code></pre></div><p>Next, we need source Android&rsquo;s environment setup script to adjust the PATH variable and add the functions that it uses.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ . build/envsetup.sh
</code></pre></div><p>After that, we need to use the <code>lunch</code> command to tell the build system that we want to build Cuttlefish.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lunch aosp_cf_x86_phone-userdebug
</code></pre></div><p>Next, we&rsquo;re just going to build the world:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ m
</code></pre></div><p>This will probably take a while since there are usually around 80,000+ files to build. A clean build on <a href="https://www.packet.com/cloud/servers/g2-large/">g2.large.x86</a> takes about 38 minutes.</p>
<p>Once it is done, you can use the <code>launch_cvd</code> command available in <code>PATH</code> to use the new files you just build. The <code>HOME=</code> assignment should still be used to keep the Cuttlefish runtime files contained but I will keep them in the <code>out</code> folder.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ HOME<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>PWD<span style="color:#e6db74">}</span>/out launch_cvd -daemon
</code></pre></div><p>Once it has booted, you can access with the <code>adb</code> that is in the path.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ adb shell
vsoc_x86:/ $ cat /proc/version
Linux version 5.4.15-gb2b96d09ef40 <span style="color:#f92672">(</span>android-build@abfarm-01061<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>Android <span style="color:#f92672">(</span><span style="color:#ae81ff">6051079</span> based on r370808<span style="color:#f92672">)</span> clang version 10.0.1 <span style="color:#f92672">(</span>https://android.googlesource.com/toolchain/llvm-project b9738d6d99f614c8bf7a3e7c769659b313b88244<span style="color:#f92672">))</span> <span style="color:#75715e">#1 SMP PREEMPT Mon Jan 27 13:04:43 UTC 2020</span>
</code></pre></div><p>The kernel is still prebuilt but you can use a kernel that you build earlier with this new userspace just like before.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ HOME<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>PWD<span style="color:#e6db74">}</span>/out launch_cvd -daemon -initramfs_path <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>DIST_FOLDER<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/initramfs.img -kernel_path <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>DIST_FOLDER<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>/bzImage
$ adb shell
vsoc_x86:/ $ cat /proc/version
Linux version 5.5.0-mainline-03266-g1dad8acc36fc-dirty <span style="color:#f92672">(</span>nathan@g2-large-x86<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>ClangBuiltLinux clang version 11.0.0 <span style="color:#f92672">(</span>git://github.com/llvm/llvm-project 64cb77b9469207799e570483dadc720dbf12c794<span style="color:#f92672">))</span> <span style="color:#75715e">#1 repo:common-android-mainline SMP PREEMPT Fri Jan 31 23:47:57</span>
</code></pre></div><h1 id="conclusion">Conclusion</h1>
<p>Hopefully this was information for you! Some further things to potentially explore are things like <a href="https://github.com/joelagnel/adeb">adeb</a>, which allow you to use tracing tools and other Linux utilities on Android to poke around its internals and try and improve or break things or looking into some of the new cool things they are doing like Apex. If you have any questions or problems, feel free to reach out to me on Twitter or GitHub, both of which are linked on my homepage.</p>
]]></content>
        </item>
        
        <item>
            <title>Building the WSL 2 kernel with Clang</title>
            <link>https://nathanchance.dev/posts/wsl2-kernel-clang/</link>
            <pubDate>Tue, 17 Dec 2019 13:53:23 -0700</pubDate>
            
            <guid>https://nathanchance.dev/posts/wsl2-kernel-clang/</guid>
            <description>Recently, I built a computer for school that I installed Windows 10 Pro on (link to the current specs if you are curious). I was a little bummed about leaving Chrome OS because I was going to lose my local Linux development environment; however, Windows Subsystem for Linux is a thing and it has gotten even better with WSL 2, as it is actually running a Linux kernel so there is full Linux compatibility going forward.</description>
            <content type="html"><![CDATA[<p>Recently, I built a computer for school that I installed Windows 10 Pro on (<a href="https://pcpartpicker.com/user/nchancellor/saved/bLjTCJ">link to the current specs</a> if you are curious). I was a little bummed about leaving Chrome OS because I was going to lose my local Linux development environment; however, Windows Subsystem for Linux is a thing and it has gotten even better with WSL 2, as it is actually running a Linux kernel so there is full Linux compatibility going forward. I also learned that it is possible to replace the Linux kernel that Microsoft ships with your own. This is a mini guide for what I uncovered because there is not a ton of information around for how to do this.</p>
<h2 id="building-the-kernel">Building the kernel</h2>
<p>You can either build the kernel on another machine and download it locally or you can build it within WSL 2 itself. This is a guide for how to do the latter because it is simpler and does not mess with an existing environment you might have working. I am giving the instructions for Debian but these should work for Ubuntu (I just do not want to tear down my current working environment to test&hellip;). I am also going to assume that you are familiar with Linux in general so I am not going to explain every single command.</p>
<h3 id="1-download-and-install-the-needed-tools">1. Download and install the needed tools.</h3>
<p>First, we are going to grab the utilities needed to build the kernel, along with some other tools to use for installing clang-10 and lld-10 from apt.llvm.org.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt update
$ sudo apt upgrade
$ sudo apt install -y --no-install-recommends <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>bc <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>bison <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>build-essential <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>ca-certificates <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>flex <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>git <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>gnupg <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>libelf-dev <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>libssl-dev <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>lsb-release <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>software-properties-common <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>wget
</code></pre></div><p>Next, we will install a rolling release version of clang-10 and lld-10 from apt.llvm.org. There has been a lot of work done on the LLVM side to make building the Linux kernel a good experience and it is important to have all of those fixes available.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cd ~
$ wget https://apt.llvm.org/llvm.sh
$ chmod +x llvm.sh
$ sudo ./llvm.sh <span style="color:#ae81ff">10</span>
</code></pre></div><p>If you are not on an Ubuntu or Debian based operating system, you can build <code>clang</code> and <code>ld.lld</code> from source easily with my <a href="https://github.com/ClangBuiltLinux/tc-build"><code>tc-build</code> script</a>. Read the information in that README for how to use it and file issues at that repo if you run into any, I want to fix them!</p>
<h3 id="2-download-the-wsl-2-source-code">2. Download the WSL 2 source code.</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git clone https://github.com/microsoft/WSL2-Linux-Kernel
$ cd WSL2-Linux-Kernel
</code></pre></div><h3 id="3-build-the-kernel">3. Build the kernel.</h3>
<p>I chose to use an out folder for easy clean up.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ make -j<span style="color:#66d9ef">$(</span>nproc<span style="color:#66d9ef">)</span> -s CC<span style="color:#f92672">=</span>clang-10 KCONFIG_CONFIG<span style="color:#f92672">=</span>../Microsoft/config-wsl LD<span style="color:#f92672">=</span>ld.lld-10 O<span style="color:#f92672">=</span>out.x86_64 distclean olddefconfig all
</code></pre></div><p>If you want to just build it in tree:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ make -j<span style="color:#66d9ef">$(</span>nproc<span style="color:#66d9ef">)</span> -s CC<span style="color:#f92672">=</span>clang-10 KCONFIG_CONFIG<span style="color:#f92672">=</span>Microsoft/config-wsl LD<span style="color:#f92672">=</span>ld.lld-10 distclean olddefconfig all
</code></pre></div><p>You do not have to use <code>clang</code> and <code>ld.lld</code>, you can omit the <code>CC=clang-10</code> and <code>LD=ld.lld-10</code> to use <code>gcc</code> and <code>ld</code> respectively but I think that using <code>clang</code> is neat since I work on <a href="https://github.com/ClangBuiltLinux">ClangBuiltLinux</a>.</p>
<h2 id="using-the-kernel">Using the kernel</h2>
<p>To boot from the kernel we just compiled, we need to move it out of WSL 2 and add a <code>.wslconfig</code> to say that we want to boot from it.</p>
<h3 id="1-move-the-kernel-to-the-windows-file-system">1. Move the kernel to the Windows file system.</h3>
<p>I have a separate folder for my kernels within my user folder (e.g., <code>C:\Users\natec\Linux</code>). It does not have to be there. Assuming that you used the out folder like I did above, the command will look something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cp out.x86_64/arch/x86/boot/bzImage /mnt/c/Users/natec/Linux/kernel-4.19-clang
</code></pre></div><h3 id="2-tell-wsl-2-to-use-that-kernel-when-booting-up">2. Tell WSL 2 to use that kernel when booting up.</h3>
<p>This was the tricky part that I had to do some reading about, as their documentation is not the best. This <code>.wslconfig</code> file has to be in your user folder&rsquo;s root (e.g., <code>C:\Users\natec\.wslconfig</code>). This is mine:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /mnt/c/Users/natec/.wslconfig
<span style="color:#f92672">[</span>wsl2<span style="color:#f92672">]</span>
kernel <span style="color:#f92672">=</span> C:<span style="color:#ae81ff">\\</span>Users<span style="color:#ae81ff">\\</span>natec<span style="color:#ae81ff">\\</span>Linux<span style="color:#ae81ff">\\</span>kernel-4.19-clang
</code></pre></div><p>You can create this with Visual Studio Code or a terminal editor like <code>vim</code>. Basically, you pass it the full path to your kernel binary with the &ldquo;<code>\</code>&rdquo; characters escaped. After that, you need to shutdown your WSL 2 VM in Powershell or <code>cmd</code> and just reopen it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wsl --shutdown
</code></pre></div><p>After you have done that, you can run <code>cat /proc/version</code> to verify that WSL booted from that kernel.</p>
<p>Before:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /proc/version
Linux version 4.19.84-microsoft-standard <span style="color:#f92672">(</span>oe-user@oe-host<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>gcc version 8.2.0 <span style="color:#f92672">(</span>GCC<span style="color:#f92672">))</span> <span style="color:#75715e">#1 SMP Wed Nov 13 11:44:37 UTC 2019</span>
</code></pre></div><p>After:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /proc/version
Linux version 4.19.84-microsoft-standard+ <span style="color:#f92672">(</span>nathan@Ryzen-7-3700X<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>clang version 10.0.0-+20191217115131+ddd0bb8dba2-1~exp1~20191217105722.470<span style="color:#f92672">)</span> <span style="color:#75715e">#1 SMP Tue Dec 17 17:15:48 MST 2019</span>
</code></pre></div><p>I have noticed that the VM gets stuck starting with a custom kernel at times; if that happens, run <code>wsl --shutdown</code> and try reopening one of the distributions again, it will usually work after a couple of times.</p>
<p>Feel free to reach out to me with issues or questions on <a href="https://twitter.com/nathanchance">Twitter</a> or <a href="https://github.com/nathanchance/WSL2-Linux-Kernel">my WSL 2 kernel source on Github</a>.</p>
]]></content>
        </item>
        
    </channel>
</rss>
